// Prisma schema file (schema.prisma)

generator client {
  provider = "prisma-client-js"
  output   = "../node_modules/.prisma/client"
}

datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
  // relationMode = "prisma"
}

// Enums
enum UserRole {
  STUDENT
  TEACHER
  ADMIN
}

enum QuestionType {
  MULTIPLE_CHOICE
  MATCHING
  SHORT_RESPONSE
  IMAGE_UPLOAD
}

enum SenderType {
  USER // Direct messaging between users
  AI // Conversations with the AI chatbot
}

// User model
model User {
  id             String    @id @default(auto()) @map("_id") @db.ObjectId
  name           String?
  email          String?   @unique
  emailVerified  DateTime? @map("email_verified")
  phoneNumber    String?
  image          String?
  hashedPassword String?
  firstTime      Boolean   @default(true)

  role     UserRole  @default(STUDENT)
  accounts Account[]
  sessions Session[]

  // User-specific information
  contextFiles     ContextFiles[]
  createdQuestions Question[]     @relation("UserCreatedQuestions")
  createdQuizzes   Quiz[]         @relation("UserCreatedQuizzes")

  // generated-user-specific
  keyTerms    KeyTerm[]
  mindMaps    MindMap[]
  memoryItems MemoryItem[]

  // used for statistics
  quizzesTaken       QuizResponse[]      @relation("StudentResponses") // their responses/
  MCQs               MCQ[]


  // Messaging relations
  userConversations       UserConversationParticipant[]
  userMessages            UserMessage[]
  aiConversations         AIConversation[]
  
  messageSeenByUsers MessageSeenByUser[]

  // User-created models
  notes         Note[] // magic notes
  flashcardSets FlashcardSet[]

  // AI Credit Information
  totalCredit Float     @default(10000.0)
  usedCredit  Float     @default(0.0)
  aiUsages    AIUsage[]

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("users")
}

// Account model
model Account {
  id                String  @id @default(auto()) @map("_id") @db.ObjectId
  userId            String  @db.ObjectId
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.String
  access_token      String? @db.String
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.String
  session_state     String?

  createdAt DateTime @default(now()) @map(name: "created_at")
  updatedAt DateTime @default(now()) @map(name: "updated_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

// Session model
model Session {
  id           String   @id @default(auto()) @map("_id") @db.ObjectId
  sessionToken String   @unique
  userId       String   @db.ObjectId
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("sessions")
}

model ContextFiles {
  id         String @id @default(auto()) @map("_id") @db.ObjectId
  gradeLevel String
  subject    String

  syllabusText String
  notesText    String

  userId String @db.ObjectId
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  quizzes Quiz[]

  @@map("context_files")
}

model Quiz {
  id          String   @id @default(auto()) @map("_id") @db.ObjectId
  title       String
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  creatorId String @db.ObjectId
  creator   User   @relation(fields: [creatorId], references: [id], onDelete: Cascade)

  quizItems     QuizItem[]
  quizResponses QuizResponse[]

  // Relations to context(where it is created from) and reference to generate flashcards with quiz

  // contextFileId String?        @db.ObjectId
  // contextFile   ContextFiles?  @relation(fields: [contextFileId], references: [id], onDelete: SetNull)
  // flashcardSetId String?       @db.ObjectId
  // flashcardSet   FlashcardSet? @relation(name: "QuizToFlashcardSet", fields: [flashcardSetId], references: [id])
}

// Quiz Question
model Question {
  id             String       @id @default(auto()) @map("_id") @db.ObjectId
  content        String // The question text
  type           QuestionType
  options        String[] // For MULTIPLE_CHOICE and MATCHING
  correctAnswers String[] // Correct answers
  explanation    String? // Explanation for the answer

  // keywords  String[] // For SHORT_RESPONSE grading
  // imagePath String? // For IMAGE_UPLOAD questions

  createdById String @db.ObjectId
  createdBy   User   @relation(fields: [createdById], references: [id], onDelete: Cascade)

  noteId String? @db.ObjectId
  note   Note?   @relation(fields: [noteId], references: [id], onDelete: Cascade)

  quizItems QuizItem[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model QuizItem {
  id     String @id @default(auto()) @map("_id") @db.ObjectId
  quizId String @db.ObjectId
  quiz   Quiz   @relation(fields: [quizId], references: [id], onDelete: Cascade)

  questionId String   @db.ObjectId
  question   Question @relation(fields: [questionId], references: [id], onDelete: Cascade)

  order Int // The order of the question in the quiz
}

model QuizResponse {
  id     String @id @default(auto()) @map("_id") @db.ObjectId
  userId String @db.ObjectId
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  quizId String @db.ObjectId
  quiz   Quiz   @relation(fields: [quizId], references: [id], onDelete: Cascade)

  responses Json // Stores user's answers to questions
  score     Float?
  createdAt DateTime @default(now())

  // imagePaths String[] // For IMAGE_UPLOAD questions
  // score      Float
  // createdAt  DateTime @default(now())
  // feedback   String[] // Feedback per question
  // incorrectQuestions QuizQuestion[] @relation("IncorrectQuestions")
}

// FlashcardSet model
model FlashcardSet {
  id         String      @id @default(auto()) @map("_id") @db.ObjectId
  title      String
  subject    String
  flashcards Flashcard[]

  quizzes Quiz[] @relation(name: "QuizToFlashcardSet")

  userId String @db.ObjectId
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("flashcard_sets")
}

// Flashcard model
model Flashcard {
  id      String  @id @default(auto()) @map("_id") @db.ObjectId
  title   String // Title or topic of the flashcard
  front   String // Question or prompt side
  back    String // Answer or explanation side
  source  String // Source of the flashcard content
  isSaved Boolean @default(false)

  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
  lastReviewedAt DateTime?

  flashcardSetId String       @db.ObjectId
  flashcardSet   FlashcardSet @relation(fields: [flashcardSetId], references: [id], onDelete: Cascade)

  noteId String? @db.ObjectId
  note   Note?   @relation(fields: [noteId], references: [id], onDelete: Cascade)

  createdById String @db.ObjectId // User who created the flashcard
  createdBy   User   @relation(fields: [createdById], references: [id], onDelete: Cascade)

  createdByAI Boolean @default(false) // Indicates if created by the chatbot

  @@map("flashcards")
}

// Magic Notes
model Note {
  id              String  @id @default(auto()) @map("_id") @db.ObjectId
  title           String // Title of the note
  content         String // Original content of the note
  enhancedContent String? // AI-enhanced version with highlights, examples, etc.

  userId String @db.ObjectId
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  noteConcepts NoteConcept[]
  flashcards   Flashcard[]
  mindMaps     MindMap[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  createdByAI Boolean @default(false) // Indicates if modified by the chatbot

  @@map("notes")
}

// Underlined highlighted hover keyterm
model KeyTerm {
  id          String @id @default(auto()) @map("_id") @db.ObjectId
  term        String
  explanation String // From web query/scraping
  analogy     String // Simplified explanation using AI

  noteId String @db.ObjectId
  note   Note   @relation(fields: [noteId], references: [id], onDelete: Cascade)

  // Optional: If key terms are shared across notes, consider many-to-many relation
  // notes          Note[]   @relation("KeyTermNotes")

  userId String @db.ObjectId
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("key_terms")
}

model Concept {
  id          String  @id @default(auto()) @map("_id") @db.ObjectId
  name        String
  description String?

  parentId String?   @db.ObjectId
  parent   Concept?  @relation("ConceptHierarchy", fields: [parentId], references: [id])
  children Concept[] @relation("ConceptHierarchy")

  createdById String @db.ObjectId
  createdBy   User   @relation(fields: [createdById], references: [id], onDelete: Cascade)

  noteConcepts NoteConcept[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Associate concepts with a note
model NoteConcept {
  id        String @id @default(auto()) @map("_id") @db.ObjectId
  noteId    String @db.ObjectId
  conceptId String @db.ObjectId

  note    Note    @relation(fields: [noteId], references: [id], onDelete: Cascade)
  concept Concept @relation(fields: [conceptId], references: [id], onDelete: Cascade)

  @@unique([noteId, conceptId])
}

// MindMap model
model MindMap {
  id    String @id @default(auto()) @map("_id") @db.ObjectId
  title String
  nodes String // JSON structure representing nodes and edges

  noteId String @db.ObjectId
  note   Note   @relation(fields: [noteId], references: [id], onDelete: Cascade)

  userId String @db.ObjectId
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@map("mind_maps")
}

// MemoryItem model
model MemoryItem {
  id      String @id @default(auto()) @map("_id") @db.ObjectId
  content String // Snapshot of the content
  type    String // e.g., "Flashcard", "Note", "KeyTerm"

  referenceId   String @db.ObjectId // ID of the original item
  referenceType String // Model type of the original item

  userId String @db.ObjectId
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@map("memory_items")
}

// AIUsage model
model AIUsage {
  id     String @id @default(auto()) @map("_id") @db.ObjectId
  userId String @db.ObjectId
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  endpoint   String // API endpoint used
  tokensUsed Int // Number of tokens used
  cost       Float // Cost in credits
  timestamp  DateTime @default(now())

  // Removed relations to Note and Conversation as per your requirements

  @@map("ai_usages")
}

// Conversation model
model Conversation {
  id            String           @id @default(auto()) @map("_id") @db.ObjectId
  createdAt     DateTime         @default(now())
  lastMessageAt DateTime         @default(now())
  name          String?
  isGroup       Boolean? // Indicates if it's a group chat (user-to-user)
  type          ConversationType // Differentiates between USER and AI conversations
  subject       String? // Subject/Topic for AI conversations
  contextOptOut Boolean          @default(false) // If true, conversation is not used as AI context

  messages          Message[]
  userConversations UserConversation[] // Relation to join model

  // Removed associatedNote to avoid errors and unnecessary complexity
  Note   Note?   @relation(fields: [noteId], references: [id])
  noteId String? @db.ObjectId
  Note   Note?   @relation(fields: [noteId], references: [id])

  @@map("conversations")
}

// UserConversation join model
model UserConversation {
  id             String @id @default(auto()) @map("_id") @db.ObjectId
  userId         String @db.ObjectId
  conversationId String @db.ObjectId

  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@unique([userId, conversationId], name: "user_conversation_unique")
  @@index([userId], name: "user_idx")
  @@index([conversationId], name: "conversation_idx")
  @@map("user_conversations")
}

// Message model
model Message {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  body      String?
  image     String?
  createdAt DateTime @default(now())

  senderId String @db.ObjectId
  sender   User   @relation(fields: [senderId], references: [id], onDelete: Cascade)

  conversationId String       @db.ObjectId
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  // For user-to-user messages, tracks which users have seen this message
  messageSeenByUsers MessageSeenByUser[]

  @@map("messages")
}

model AIConversation {
  id            String   @id @default(auto()) @map("_id") @db.ObjectId
  subject       String? // Subject or topic of the conversation
  contextOptOut Boolean  @default(false) // If true, conversation isn't used for AI context
  createdAt     DateTime @default(now())
  updatedAt     DateTime @default(now())

  userId String @db.ObjectId
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  aiMessages AIMessage[]

  // Optional relations to associate the conversation with a specific content item
  questionId String?   @db.ObjectId
  question   Question? @relation(fields: [questionId], references: [id])

  flashcardId String?    @db.ObjectId
  flashcard   Flashcard? @relation(fields: [flashcardId], references: [id])

  noteId String? @db.ObjectId
  note   Note?   @relation(fields: [noteId], references: [id])

  // Indexes for efficient querying
  @@index([questionId])
  @@index([flashcardId])
  @@index([noteId])
  @@map("ai_conversations")
}

model AIMessage {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  body      String? // Content of the message
  createdAt DateTime @default(now())

  conversationId String         @db.ObjectId
  conversation   AIConversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  senderType SenderType // Enum to indicate if the message is from the user or AI
  // Enum values: USER, AI

  @@map("ai_messages")
}

// MessageSeenByUser join model
model MessageSeenByUser {
  id        String @id @default(auto()) @map("_id") @db.ObjectId
  messageId String @db.ObjectId
  userId    String @db.ObjectId

  message Message @relation(fields: [messageId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([messageId, userId], name: "message_user_unique")
  @@index([messageId], name: "message_idx")
  @@index([userId], name: "user_idx")
  @@map("message_seen_by_users")
}

// Helper models
model VerificationToken {
  id      String   @id @default(cuid()) @map("_id")
  email   String
  token   String   @unique
  expires DateTime

  @@unique([email, token])
  @@map("verification_tokens")
}

model PasswordResetToken {
  id      String   @id @default(cuid()) @map("_id")
  email   String
  token   String   @unique
  expires DateTime

  @@unique([email, token])
  @@map("password_reset_tokens")
}

// Stripe
model Purchase {
  id       String   @id @default(uuid()) @map("_id")
  userId   String
  credit   Float
  createAt DateTime @default(now())
}

model StripeCustomer {
  id               String @id @default(uuid()) @map("_id")
  userId           String @unique
  stripeCustomerId String @unique

  createAt DateTime @default(now())
}

//  knowledge webs, i want it to be like
// The Graph view lets you visualize the relationships between the knowledge in your "memory".
// Circles represent concepts, or nodes.
// I want to make it into a tree like format that showcases how knowledge "stack" on top of each other, similar to how key terms build upon each other and can be shared across notes.
